.devcontainer/Dockerfileにコンテナ（実行環境）の設定が書かれている
=> 例えば、serverlessframeworkのインストールとか、FROM node:16-buster-slimでnodeのイメージを元にイメージを自作とか

.devcontainer/entrypoint.shはコンテナ作成時に実行されるコマンド（serverless frameworkにAWSアカウントを紐付けるとか、依存パッケージのインストールとか）

.devcontainer/devcontainar.jsonで起動するコンテナのイメージとか拡張機能とかeslintとかの設定が書かれていて、それがリモート接続により共有される

package.jsonに外部ライブラリの情報（宣言）（reactとか）が書かれている

yarn.lockが実際に外部ライブラリのバージョンとかの依存関係を全て解決した状態の情報を持っている

"yarn"コマンドでpackage.json、厳密にはyarn.lockを元にnode_modules（実体、reactとかのコード）を作る

node_modulesはパッケージ群のローカルのインストール先ディレクトリ、パッケージ（外部ライブラリ）のコードの置き場

.eslintrc.jsonはeslintの設定ファイル（ルールが書かれている、これをもとに解析する）

.prettierrcはprettierの設定ファイル（どのようなコードフォーマットにするのか）

.husky/pre-commitでコミット前にlinter走らせている

huskyはgitフック（gitリポジトリに特定のイベントが生じるたびに自動で実行されるスクリプト）を管理するツール

serverless.ymlにはserverlessの設定を行うファイル=>lambda functionの設定、lambda functionのトリガーとなるイベントの定義（httpリクエストに対するラムダの割り当て）

backend/handler.tsは実際のラムダ関数が書かれている。httpリクエストによって該当の関数が呼ばれ、json形式のリソースを返したり、DBを操作したりする

SPAアプリケーションとしての初めの1ページはamazonのS3において公開している。そのページのjavascriptのコードがapi経由でラムダ関数とやり取りする。

tailwind csssは素のcssを使わずに、tailwindが用意しているユーティリティクラスを主に使ってスタイリングする考え方（HTMLに直接スタイリングしてしまう）
=>クラス名を考える必要がない（ユーティリティクラスが用意されているのでその名前使う）
=>スピーディーな開発（HTMLファイルとCSSファイルを行き来することがない）
=>無駄なコードを減らせる（細かいスタイルングでなければCSSスタイリングを自分で書くことがない）

ユーティリティークラスというのは、クラス名がそのまま、cssのプロパティとその値を示している（例:margin-top-10pxをdiv要素に当てると、そのままmargin-top: 10pxのスタイリングになる）

bootstrapとの違いはデザインを作るクラスは存在せず、CSSプロパティのユーティリティクラスが用意されているのみであるところ（bootstrapはボタンが簡単に作れるクラスがあったりした）

const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setName(event.target.value)
    const newName = event.target.value
    nameValidate(newName)
  }

useStateで更新したstateは即座に更新されるわけではないので、更新直後のstateに依存する処理を行う場合には、一度更新直後のeventを新しい変数に格納して、それに対して処理を行う。
もし新しい変数に格納しないで、
setName(event.target.value)
nameValidate(name)
とすると、更新される前の（最新より一個前の）nameに対して、validationを行うことになってしまう。


errors.email?.messageについて、errors.emailが存在すれば、その値に対して、messageかます。
errors.emailが存在しなければ、何もしない。
errors.email.messageだと、errors.emailが存在しないときに、message噛ませないのでエラーが起こる

デフォルトでは一つの入力項目(name属性)に対して、一つのエラー情報しか持てないが、useForm({criteriaMode: 'all'})と引数指定すると、複数のエラー情報をもてる。
=> errors = {email: {types: {MinLength: "8文字以上", pattern: "形式が不正"}}}  みたいな感じ
=> 使わんかも

isDirtyはフォームの初期値が変わると真偽値が変わる（false=>true)

ラジオボタンはname属性同じにすると、それらが排他的な選択肢になる
同じname属性のラジオボタンは一つの要素にバリデーションかくとそのグループに適用される。（required)

overleyについて、opacityを使うと子要素も透けてしまうので、rgbaで設定する

モーダルの表示・非表示はstateで管理する

複数の子要素からデータを集めたい、または 2 つの子コンポーネントに互いにやりとりさせたいと思った場合は、
代わりに親コンポーネント内で共有の state を宣言する必要があります。
親コンポーネントは props を使うことで子に情報を返すことができます。
こうすることで、子コンポーネントが兄弟同士、あるいは親との間で常に同期されるようになります。

const Modal: FC<{ modalHidden: () => void }> = (props) => {...}
親コンポーネントから受け取るpropsにどんな属性値が含まれているかとその型を定義している。
ここでは、propsにmodalHiddenが()=>void型（戻り値がない関数の型）で含まれていることを定義している。

何人目の子供かを表示させたり、データを受け取るのにMainFormからChildFormに渡したいが、配列のインデックスが数字で得られずに、undefinedになる
=>indexを属性keyで取っていたが、キーワードなのでエラーになっていた。numで取るとできた

let childName = `childName${props.num}`
{props.errors?.[childName]?.message ? (
  <span className='block text-center text-red-600'>
    {String(props.errors[childName].message)}
  </span>}
オブジェクトのキーに変数を使うには、[変数]としてキーを指定する。（定義時も同様）

一度children追加したらregister関数で登録されて後で消してもdataに残ってしまう。
=>children削除した時に、unregisterを使って削除するchildrenのname属性指定すると、dataは参照しなくなる。

一番最近追加した子供の番号を保持するaddNum(次にどの番号追加するか決めるため)
現在有効な子供の番号の配列であるchidrenArray(この配列に入っている子供の番号が表示され、dataとして送られる)
各々の子供が持つ自分の番号であるchildNum

todo:
型定義しっかりする(anyのところ)


src/index.tsxのchildrenは何者？<Root>の<Outlet>にぶち込まれる感じ？
Rootは共通レイアウトやけど何を書く？
子供の番号の付け方をもっと凝るべき？
