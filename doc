.devcontainer/Dockerfileにコンテナ（実行環境）の設定が書かれている
=> 例えば、serverlessframeworkのインストールとか、FROM node:16-buster-slimでnodeのイメージを元にイメージを自作とか

.devcontainer/entrypoint.shはコンテナ作成時に実行されるコマンド（serverless frameworkにAWSアカウントを紐付けるとか、依存パッケージのインストールとか）

.devcontainer/devcontainar.jsonで起動するコンテナのイメージとか拡張機能とかeslintとかの設定が書かれていて、それがリモート接続により共有される

package.jsonに外部ライブラリの情報（宣言）（reactとか）が書かれている

yarn.lockが実際に外部ライブラリのバージョンとかの依存関係を全て解決した状態の情報を持っている

"yarn"コマンドでpackage.json、厳密にはyarn.lockを元にnode_modules（実体、reactとかのコード）を作る

node_modulesはパッケージ群のローカルのインストール先ディレクトリ、パッケージ（外部ライブラリ）のコードの置き場

.eslintrc.jsonはeslintの設定ファイル（ルールが書かれている、これをもとに解析する）

.prettierrcはprettierの設定ファイル（どのようなコードフォーマットにするのか）

.husky/pre-commitでコミット前にlinter走らせている

huskyはgitフック（gitリポジトリに特定のイベントが生じるたびに自動で実行されるスクリプト）を管理するツール

serverless.ymlにはserverlessの設定を行うファイル=>lambda functionの設定、lambda functionのトリガーとなるイベントの定義（httpリクエストに対するラムダの割り当て）

backend/handler.tsは実際のラムダ関数が書かれている。httpリクエストによって該当の関数が呼ばれ、json形式のリソースを返したり、DBを操作したりする

SPAアプリケーションとしての初めの1ページはamazonのS3において公開している。そのページのjavascriptのコードがapi経由でラムダ関数とやり取りする。

tailwind csssは素のcssを使わずに、tailwindが用意しているユーティリティクラスを主に使ってスタイリングする考え方（HTMLに直接スタイリングしてしまう）
=>クラス名を考える必要がない（ユーティリティクラスが用意されているのでその名前使う）
=>スピーディーな開発（HTMLファイルとCSSファイルを行き来することがない）
=>無駄なコードを減らせる（細かいスタイルングでなければCSSスタイリングを自分で書くことがない）

ユーティリティークラスというのは、クラス名がそのまま、cssのプロパティとその値を示している（例:margin-top-10pxをdiv要素に当てると、そのままmargin-top: 10pxのスタイリングになる）

bootstrapとの違いはデザインを作るクラスは存在せず、CSSプロパティのユーティリティクラスが用意されているのみであるところ（bootstrapはボタンが簡単に作れるクラスがあったりした）

const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setName(event.target.value)
    const newName = event.target.value
    nameValidate(newName)
  }

useStateで更新したstateは即座に更新されるわけではないので、更新直後のstateに依存する処理を行う場合には、一度更新直後のeventを新しい変数に格納して、それに対して処理を行う。
もし新しい変数に格納しないで、
setName(event.target.value)
nameValidate(name)
とすると、更新される前の（最新より一個前の）nameに対して、validationを行うことになってしまう。


errors.email?.messageについて、errors.emailが存在すれば、その値に対して、messageかます。
errors.emailが存在しなければ、何もしない。
errors.email.messageだと、errors.emailが存在しないときに、message噛ませないのでエラーが起こる

errors.name.messageはFiledError型で、FieldError型はReactNodeに割り当てられないので、文字列に変換した

デフォルトでは一つの入力項目(name属性)に対して、一つのエラー情報しか持てないが、useForm({criteriaMode: 'all'})と引数指定すると、複数のエラー情報をもてる。
=> errors = {email: {types: {MinLength: "8文字以上", pattern: "形式が不正"}}}  みたいな感じ
=> 使わんかも

isDirtyはフォームの初期値が変わると真偽値が変わる（false=>true)

ラジオボタンはname属性同じにすると、それらが排他的な選択肢になる
同じname属性のラジオボタンは一つの要素にバリデーションかくとそのグループに適用される。（required)

overleyについて、opacityを使うと子要素も透けてしまうので、rgbaで設定する

モーダルの表示・非表示はstateで管理する

複数の子要素からデータを集めたい、または 2 つの子コンポーネントに互いにやりとりさせたいと思った場合は、
代わりに親コンポーネント内で共有の state を宣言する必要があります。
親コンポーネントは props を使うことで子に情報を返すことができます。
こうすることで、子コンポーネントが兄弟同士、あるいは親との間で常に同期されるようになります。

const Modal: FC<{ modalHidden: () => void }> = (props) => {...}
親コンポーネントから受け取るpropsにどんな属性値が含まれているかとその型を定義している。
ここでは、propsにmodalHiddenが()=>void型（戻り値がない関数の型）で含まれていることを定義している。


formコンポーネントとentryコンポーネント分けるべき？
src/index.tsxのchildrenは何者？<Root>の<Outlet>にぶち込まれる感じ？
Rootは共通レイアウトやけど何を書く？
